**[식당 스토리]**

식당을 잘 되고 있는 중에 한가지 이슈가 발생함.

손님들이 많이 몰리다 보니 일처리를 어떻게 해야할 지 고민이 됨.

![image](https://user-images.githubusercontent.com/75019048/131054214-a1b1fdb6-46b8-40eb-bc47-772ed84509de.png)

테이블에 있는 직원이 주문을 받아서 주방에 전달을 해줘야 주문이 들어감

테이블 직원이 머리 속에 저장만 한다고 해서 주문이 들어가지는 않음

그래서 주문현황이라는 기계에 다가가 주문 현황에다가 주문을 입력을 하면

주방에서도 원격으로 주문이 들어온 것을 알고 요리를 시작.

테이블 직원과 주문 현황 판이 멀리 있다. → 왔다갔다하는 시간이 아까움

![image](https://user-images.githubusercontent.com/75019048/131054224-831aa6cd-314f-4e1c-94b9-b0fe5f06f44b.png)

그래서 주문을 받자마자 주문 현황 판에 가는 것이 아니라 주문을 꾹꾹 눌러 담아 기억을 해서 모아서 한번에 주문 현황판에 기입을 하는 방법을 생각해냄

주문 현황판에 입력하기 전에 받았던 주문이 변경이 된다면 수첩에 적어놨던 주문을 지우고 다시 입력하면 된다.

![image](https://user-images.githubusercontent.com/75019048/131054232-76710360-2a2e-422d-8b68-c0fc5288fe31.png)

하지만 직원이 늘었을 경우 문제가 발생할 수 있다.

주문을 수첩에 적어 놓게 되면 다른 직원들과 공유를 하는 것이 아니다.

예를 들어 위에 직원이 먼저 콜라를 주문 받아서 미니 수첩에 콜라를 기입해놓았는데

다른 직원이 사이다로 변경된 주문을 받는다면?

혼선이 발생 할 수 밖에 없게 된다.

**[실제 컴퓨터]**

![image](https://user-images.githubusercontent.com/75019048/131054248-7dcaa799-9328-4f89-8c6b-d331a7c517a4.png)

CPU의 코어를 확대 해보면 위와 같이 ALU(연산장치)와 캐쉬(메모리) 장치가 있다.

메모리에 데이터를 기입해야하는데 물리적으로 거리가 있는 RAM에 매번 기록하기가(메모리 갱신) 쉽지는 않음

단기 기억 : 

미니 수첩 : 

![image](https://user-images.githubusercontent.com/75019048/131054263-6a0b0d7c-9861-4bab-812d-71dd354e78a7.png)

캐쉬 장치를 확대하면 또 위와 같다.

순서대로 레지스터는 단기 기억 장치, L1, L2 는 미니 수첩과 같은 중기(?) 기억 장치이다.

어떤 변수나 메모리에 있는 값을 바꾼다고 했을 때 RAM에 곧바로 바꾸는 게 아니라 일단은 캐쉬 장치에 기입을 해서 시간이 지나면 한번에 메모리에 올리는 과정을 갖는다.

![image](https://user-images.githubusercontent.com/75019048/131054279-270a87f8-56b0-4719-a5dd-655f3351b4d4.png)

무엇을 cashing할 것인가에 대한 답이 위 2가지

1) 시간과 관련 → 최근에 사용된 변수가 또 다시 사용될 수 있다는 생각에서 나옴, 방금 주문한 사람이 또 주문할 확률이 높다는 것에 착안함.

2) 공간과 관련 → 방금 접근한 변수의 주소와 인접한 변수의 주소에  또 방문할 확률이 높다.

멀티쓰레드 환경에서는 각 코어마다 각자의 캐쉬를 가지고 있고 반약 어떤 변수를 어떤 값으로 바꿨을 경우 다른 쓰레드에서는 그것을 알 수 없는 경우가 발생한다.

예를 들어 첫번째 쓰레드가 어떤 변수를 바꿨다면 다른 쓰레드가 바뀐 변수 값에 접근하는 것이 아니라 바뀌기 전 변수 값으로 접근을 할 수도 있게 된다.

싱글 쓰레드 환경에서는 메모리의 값이 바뀌면 바로 알 수 있지만 멀티 쓰레드 환경에서는 이런 가정이 깨지게 된다.

**[실습]**

```csharp
using System;

namespace ServerCore
{
    class Program
    {
        static void Main(string[] args)
        {
            int[,] arr = new int[10000, 10000];

            {
                long now = DateTime.Now.Ticks;
                for (int y = 0; y < 10000; y++)
                {
                    for (int x = 0; x < 10000; x++)
                    {
                        arr[y,x] = 1;
                    }
                }
                long end = DateTime.Now.Ticks;
                System.Console.WriteLine($"(y,x) 순서 걸린 시간 : {end - now}");
            }

            {
                long now = DateTime.Now.Ticks;
                for (int y = 0; y < 10000; y++)
                {
                    for (int x = 0; x < 10000; x++)
                    {
                        arr[x,y] = 1;
                    }
                }
                long end = DateTime.Now.Ticks;
                System.Console.WriteLine($"(x,y) 순서 걸린 시간 : {end - now}");
            }

            // 수학적으로 보면 동일해야하는 데 과연 결과는?

            // 이곳 컴퓨터 기준
            // 1988577
            // 3475538

            // 생각보다 많이 차이가 발생
            // 왜 그럴까?
            // 공간적(Special Locality)
            // 어떤 변수에 접근할 때 해당 주소 근처에 있는 변수 값에 접근할 확률이 높을 것이다.

            // 5 * 5 배열
            // [1] [1] [1] [1] [1]  
            // [] [] [] [] []  
            // [] [] [] [] []  
            // [] [] [] [] []  
            // [] [] [] [] []  
            // x의 값을 먼저 늘리기 때문에 행의 값을 먼저 할당함
            // 행의 주소가 인접해 있기 때문에 캐쉬에 저장을 해서 
            // 값을 할당하는 방식이라 좀더 빠르다.

            // 5 * 5 배열
            // [1] [] [] [] []  
            // [1] [] [] [] []  
            // [1] [] [] [] []  
            // [1] [] [] [] []  
            // [1] [] [] [] []  
            // x의 값을 먼저 늘리기 때문에 열의 값을 먼저 할당함
            // 주소의 거리가 좀더 멀기 때문에 
            // 값을 할당하는 시간이 조금 더 느리다.

        }

    }
}
```