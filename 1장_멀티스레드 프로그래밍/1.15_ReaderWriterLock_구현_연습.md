**Lock.csì˜ ì—­í• **
ReaderWriterLockì„ ì§ì ‘ êµ¬í˜„í•¨. (ê¸°ë³¸ .NETì˜ ReaderWriterLock ì•ˆ ì”€)

ReadLock(), WriteLock() í•¨ìˆ˜ ì§ì ‘ êµ¬í˜„.

```csharp
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;

namespace ServerCore
{
    // lock ìƒì„± ì •ì±…
    // ì¬ê·€ì  ë½ì„ í—ˆìš©í• ì§€ (No) 
    // => WriteLockì„ Acquireí•œ ìƒíƒœì—ì„œ ë˜ ë‹¤ì‹œ ì¬ê·€ì ìœ¼ë¡œ ê°™ì€ ì“°ë ˆë“œì—ì„œ Acquireë¥¼ ì‹œë„í•˜ëŠ” ê²ƒì„ í—ˆìš©í• ì§€ ì—¬ë¶€ë¥¼ ê²°ì •
    // í—ˆìš©ì„ ì•ˆí•˜ëŠ” ê²ƒì´ ì¢€ë” ì‰¬ì›€

    // SpinLock ì •ì±… (5000ë²ˆ -> Yield) 
    // Yield : ìì‹ ì˜ ì œì–´ê¶Œì„ ì–‘ë³´ 
    class Lock
    {
        // [Unused(0)] [WriteThreadId(15)] [ReadCount(16)]
        // 0000 0000 0000 0000 0000 0000 0000 0000
        // ê°€ì¥ ì™¼ìª½ 0 : Unused(0)
        // ê°€ì¥ ì™¼ìª½ 1 ~ 15 : WriteThreadId(15)
        // ê°€ì¥ ì™¼ìª½ 16 ~ 32 : ReadCount(16)
        // ê¿€íŒ : 16ì§„ìˆ˜ : 2ì§„ìˆ˜ = F : 11111
        const int EMPTY_FLAG = 0x00000000;
        const int WRITE_MASK = 0x7FFF0000;
        const int READ_MASK = 0x0000FFFF;
        const int MAX_SPIN_COUNT = 5000;

        // ReadCount : ReadLockì„ íšë“í–ˆì„ ë•Œ ì—¬ëŸ¬ ì“°ë ˆë“œì—ì„œ Readë¥¼ ì¡ì„ ìˆ˜ ìˆìŒ -> ê·¸ê²ƒì„ ì¹´ìš´íŒ…
        // WriteThreadId : WriteThreadë¥¼ ì¡ê³  ìˆëŠ” í•œê°œì˜ ì“°ë ˆë“œ
        int _flag = EMPTY_FLAG;

        // _flagë¼ëŠ” 32ë¹„íŠ¸ ì •ìˆ˜ í•˜ë‚˜ë¡œ ìƒíƒœë¥¼ ê´€ë¦¬
        // [Unused (1)] [WriteThreadId (15)] [ReadCount (16)]
        // -----------------------------------------------
        // |     0     |     ì“°ê¸° ìŠ¤ë ˆë“œ ID     | ì½ê¸° ì¹´ìš´íŠ¸ |
        // ì“°ê¸° ì ê¸ˆ: _flagì˜ ìƒìœ„ 15ë¹„íŠ¸ë¥¼ í˜„ì¬ ìŠ¤ë ˆë“œ IDë¡œ ì„¤ì •
        // ì½ê¸° ì ê¸ˆ: _flagì˜ í•˜ìœ„ 16ë¹„íŠ¸ë¥¼ 1ì”© ì¦ê°€


        public void WriteLock()
        {
            // ì•„ë¬´ë„ WriteLock or ReadLockì„ íšë“í•˜ê³  ìˆì§€ ì•Šì„ ë•Œ, ê²½í•©í•´ì„œ ì†Œìœ ê¶Œì„ ì–»ëŠ”ë‹¤.
            int desired = (Thread.CurrentThread.ManagedThreadId << 16) & WRITE_MASK;
            // Thread.CurrentThread.ManagedThreadIdëŠ” í˜„ì¬ ìŠ¤ë ˆë“œì˜ IDë¥¼ ê°€ì ¸ì˜´
            // << 16, ìŠ¤ë ˆë“œ ID ê°’ì„ ì™¼ìª½ìœ¼ë¡œ 16ë¹„íŠ¸ ì‹œí”„íŠ¸
            // &ëŠ” ë¹„íŠ¸ AND ì—°ì‚°ì, "í•„ìš”í•œ ë¹„íŠ¸ë§Œ ë‚¨ê¸°ê¸° (ë§ˆìŠ¤í‚¹)"
            // ì¦‰, & ì—°ì‚°ì„ í•˜ë©´ â†’ ìƒìœ„ 15ë¹„íŠ¸ëŠ” ë‚¨ê¸°ê³  ë‚˜ë¨¸ì§€ëŠ” 0ìœ¼ë¡œ ë§Œë“ ë‹¤
            // í˜„ì¬ ìŠ¤ë ˆë“œ IDë¥¼ ìƒìœ„ ë¹„íŠ¸ì— ë„£ìŒ.
            // _flag == 0 (ì•„ë¬´ë„ ì•ˆ ì“°ëŠ” ìƒíƒœ)ì¼ ë•Œ, ìì‹ ì˜ IDë¡œ ì„¸íŒ… ì‹œë„.
            // ì•ˆ ë˜ë©´ ê³„ì† ë°˜ë³µ (SpinLock ë°©ì‹, 5000ë²ˆ ë°˜ë³µ í›„ Thread.Yield())

            while (true)
            {
                for (int i = 0; i < MAX_SPIN_COUNT; i++)
                {
                    // ì‹œë„ë¥¼ í•´ì„œ EMPTY_FLAGì™€ ê°™ìœ¼ë©´ return
                    if (Interlocked.CompareExchange(ref _flag, desired, EMPTY_FLAG) == EMPTY_FLAG) // Interlocked: ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ì›ìì (atomic) ì—°ì‚° ì œê³µ â†’ ë°ì´í„° ê²½í•© ë°©ì§€
                    {
                        return;
                    }

                    // if (_flag == EMPTY_FLAG)
                    // {
                    //     _flag = desired;
                    //      return;
                    // }
                }
                Thread.Yield();
            }
        }
        public void WriteUnlock()
        {
            // ì´ˆê¸° ìƒíƒœë¡œ ë³€ê²½
            Interlocked.Exchange(ref _flag, EMPTY_FLAG);
            // _flagë¥¼ 0ìœ¼ë¡œ ì´ˆê¸°í™”í•´ì„œ ì ê¸ˆ í•´ì œ
        }
        public void ReadLock()
        {
            // ì•„ë¬´ë„ WriteLockì„ íšë“í•˜ê³  ìˆì§€ ì•Šìœ¼ë©´, ReadCountë¥¼ 1 ëŠ˜ë¦°ë‹¤.
            // ReadLock ê°™ì€ ê²½ìš°ëŠ” ëˆ„êµ¬ë‚˜ ì ‘ê·¼ì´ ê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì— ì¿¨í•˜ê²Œ 1ì”© ëŠ˜ë ¤ì¤€ë‹¤.
            while (true)
            {
                for (int i = 0; i < MAX_SPIN_COUNT; i++)
                {
                    // Lock Free Programming ê¸°ì´ˆ

                    // ë§Œì•½ ëˆ„êµ°ê°€ lockì„ ì¡ê³  ìˆë‹¤ë©´(WriteLock) 
                    // expected ê°’ì´ ë‚´ê°€ ì›í•˜ëŠ” ê°’ì´ ì•„ë‹ í…Œë‹ˆê¹  
                    // ì•„ë˜ if ë¬¸ì—ì„œ ì‹¤íŒ¨ë¥¼ í•˜ê²Œ ë  ê²ƒì´ë‹¤.
                    int expected = (_flag & READ_MASK); // READ_MASK ë¶€ë¶„ë§Œ ì¶”ì¶œ


                    // CompareExchange(ref location, newValue, expectedValue)
                    // locationì˜ ê°’ì´ expectedValueì™€ ê°™ìœ¼ë©´ -> locationì„ newValueë¡œ ë°”ê¾¼ë‹¤ (ì›ìì ìœ¼ë¡œ)
                    // ê·¸ë¦¬ê³  ì´ì „ ê°’ì„ ë¦¬í„´í•¨ 
                    // ì•„ë˜ if ë¬¸ì´ ì„±ê³µí–ˆë‹¤ëŠ” ì˜ë¯¸ëŠ” (_flag & WRITE_MASK) == 0ê³¼ ë™ì¼(ìƒìœ„ ë¹„íŠ¸(WriteThreadId)ê°€ 0)
                    // ì¦‰ flagê³¼ expectedê°€ ë™ì¼ => flagê°’ì„ 1 ë”í•´ì¤Œ
                    // ì¦‰ ReadLockì„ ì„±ê³µí•˜ê³  ë”ì´ìƒ ì‹œë„í•˜ì§€ ì•ŠìŒ
                    if (Interlocked.CompareExchange(ref _flag, expected + 1, expected) == expected)
                    // ì“°ê¸° ì‘ì—…ì´ ì—†ì„ ë•Œë§Œ ì½ê¸° ì¹´ìš´íŠ¸ë¥¼ ì¦ê°€í•¨.
                    // ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ê²½í•©í•˜ë©´, í•œ ìŠ¤ë ˆë“œë§Œ ì„±ê³µí•˜ê³  ë‚˜ë¨¸ì§€ëŠ” ì¬ì‹œë„.
                    {
                        return;
                    }
                    // ì²´í¬ë¥¼ í•˜ê³  1ì„ ëŠ˜ë¦¬ëŠ” ìƒí™©ì—ì„œ ë‹¤ë¥¸ ì“°ë ˆë“œì—ì„œ ì ‘ê·¼ì„ í•˜ë©´ ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŒ
                    // if ((_flag & WRITE_MASK) == 0)
                    // {
                    //     _flag = _flag + 1;
                    //     return;
                    // }
                }
                Thread.Yield();
            }

            // ìœ„ì˜ ì˜ˆì œë¥¼ ì´í•´í•˜ê¸° ìœ„í•œ ì‹œë‚˜ë¦¬ì˜¤
            // ë‘ê°œì˜ ì“°ë ˆë“œê°€ ê±°ì˜ ë™ì‹œì— ReadLockì— ì§„ì…ì„ í–ˆê³  Aê°€ Bë³´ë‹¤ ë¨¼ì € ì§„ì…ì„ í–ˆë‹¤ë©´
            // A expected : 0
            // B expected : 0
            // (_flag & WRITE_MASK) == 0 ?, A => 1
            // (_flag & WRITE_MASK) == 0 ?, B => 1 
            // ì´ë ‡ê²Œ ê²½í•©ì„ í•˜ê²Œ ë¨
            // Aê°€ ë¨¼ì € ì‹¤í–‰ë˜ì—ˆë‹¤ê³  ê°€ì •í•˜ë©´
            // flagëŠ” 1ë¡œ ë°”ë€œ => AëŠ” ì„±ê³µ
            // ê·¸ ë‹¤ìŒ BëŠ” flagê°€ ì´ë¯¸ ë°”ë€Œì—ˆê¸° ë•Œë¬¸ì— ì‹¤íŒ¨ => ë‹¤ì‹œ ì¬ì‹œë„
            // ì™œ ì¬ì‹œë„ê°€ í•„ìš”í• ê¹Œ?
            // CompareExchangeëŠ” ì›ìì ìœ¼ë¡œ ë™ì‘í•˜ë‹ˆê¹Œ
            // "í•œ ë²ˆì— í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œë§Œ" ì„±ê³µí•  ìˆ˜ ìˆì–´.
            // ReadLockì€ ë™ì‹œì— ì—¬ëŸ¬ ê°œ ê°€ëŠ¥í•˜ì§€ë§Œ(ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ReadLockì„ ë™ì‹œì— â€œê°€ì§€ê³  ìˆëŠ”â€ ìƒíƒœëŠ” ê°€ëŠ¥í•¨)
            // ê°’ ì¦ê°€(Write) ìì²´ëŠ” ì›ìì ìœ¼ë¡œ í•´ì•¼ í•˜ë‹ˆê¹Œ ìˆœì°¨ì ìœ¼ë¡œ ì²˜ë¦¬í•´ì•¼ í•¨.(ê° ìŠ¤ë ˆë“œëŠ” ìˆœì°¨ì ìœ¼ë¡œ ê°’ ì¦ê°€ í•´ì•¼ í•¨)

            // ë¹„ìœ í•˜ìë©´, ì»¤í”¼ ìíŒê¸°ì— ì¤„ì„ ì„œëŠ” ìƒí™©ì´ë¼ê³  ìƒê°í•´ë´
            // ì»µì€ ì—¬ëŸ¬ ê°œ ë‚˜ì˜¬ ìˆ˜ ìˆì–´ (ì—¬ëŸ¬ ëª… Read ê°€ëŠ¥)
            // í•˜ì§€ë§Œ ë¬¼ ë¶“ëŠ” ë²„íŠ¼ì€ í•œ ëª…ì”©ë§Œ ëˆ„ë¥¼ ìˆ˜ ìˆì–´ (ê°’ ì¦ê°€ëŠ” ì›ìì ìœ¼ë¡œ í•´ì•¼ í•¨)
            // Aê°€ ë¨¼ì € ë²„íŠ¼ ëˆ„ë¥´ê³  ì»µ ë°›ìŒ â†’ BëŠ” ì ê¹ ê¸°ë‹¤ë ¸ë‹¤ê°€ ë‹¤ì‹œ ì‹œë„í•´ì•¼ í•´

        }
        public void ReadUnlock()
        {
            // ì½ê¸° ì¹´ìš´íŠ¸ë¥¼ í•˜ë‚˜ ì¤„ì„.
            Interlocked.Decrement(ref _flag);
        }
    }
}
```
ReadLock vs WriteLock ë¹„ìœ : â€œë„ì„œê´€ ì±… ì½ê¸° vs ìˆ˜ì •â€

ğŸ“– ë¹„ìœ  ì˜ˆì‹œ
âœ… ReadLock = ì—¬ëŸ¬ ì‚¬ëŒì´ ì±…ì„ ì½ëŠ” ìƒí™©

- ë…ì A, B, Cê°€ ì±…ì„ â€œì½ê¸°ë§Œâ€ í•˜ëŠ” ê±´ ë™ì‹œì— ê°€ëŠ¥í•´

- ì„œë¡œ ë°©í•´ ì•ˆ ë¨

- ì¤‘ìš”í•œ ê±´: ì±…ì„ ë°”ê¾¸ëŠ” ì‚¬ëŒ(Write)ì´ ìˆì„ ë• ì ˆëŒ€ ëª» ë“¤ì–´ê°

â†’ â€œì±…ìƒ ìœ„ì— ì±…ì„ ë‘ê³  ì—¬ëŸ¬ ì‚¬ëŒì´ ëŒì•„ê°€ë©° ì½ëŠ” ìƒí™©â€

ğŸ”’ WriteLock = í•œ ì‚¬ëŒì´ ì±… ë‚´ìš©ì„ ê³ ì¹˜ëŠ” ìƒí™©

- Aê°€ ì±… ë‚´ìš©ì„ ìˆ˜ì •í•˜ë ¤ë©´ â†’ ë„ì„œê´€ ì „ì²´ë¥¼ ë¹„ì›Œì•¼ í•¨

- ì•„ë¬´ë„ ì±…ì„ ì½ê³  ìˆì–´ì„  ì•ˆ ë˜ê³ , ë‹¤ë¥¸ ìˆ˜ì •ìë„ ì—†ì–´ì•¼ í•¨

- í˜¼ìë§Œ ë“¤ì–´ê°€ì„œ ìˆ˜ì •í•˜ê³  â†’ ëë‚˜ë©´ ë‹¤ë¥¸ ì‚¬ëŒ ì…ì¥ ê°€ëŠ¥

â†’ â€œì±…ì„ ë“¤ê³  ì‚¬ë¬´ì‹¤ì— ë“¤ì–´ê°€ì„œ ë¬¸ ì ê·¸ê³  í˜¼ì ìˆ˜ì •í•˜ëŠ” ìƒí™©â€

```csharp
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;

namespace ServerCore
{
    // lock ìƒì„± ì •ì±…
    // ì¬ê·€ì  ë½ì„ í—ˆìš©í• ì§€ (Yes)  
    // => WriteLock => WriteLock (ì¬ê·€ í—ˆìš©) 
    
    // => WriteLock => ReadLock (ì¬ê·€ í—ˆìš©)
    // (ì˜ë¯¸: í˜„ì¬ ìŠ¤ë ˆë“œê°€ WriteLockì„ ì¡ê³  ìˆì„ ë•Œ, ê°™ì€ ìŠ¤ë ˆë“œê°€ ReadLockë„ ìš”ì²­í•˜ë©´ â†’ í—ˆìš©ëœë‹¤)
    // âœ” ì™œ ê°€ëŠ¥? 
    // ì“°ê¸° ë½(WriteLock)ì„ ì¡ê³  ìˆëŠ” ë™ì•ˆì€ ê·¸ ìŠ¤ë ˆë“œë§Œ í•´ë‹¹ ìì›ì— ì ‘ê·¼ ê°€ëŠ¥í•˜ë‹ˆê¹Œ,
    // â†’ ì½ê¸° ë½(ReadLock)ì„ ê°™ì€ ìŠ¤ë ˆë“œì—ì„œ ì¶”ê°€ë¡œ ê±¸ì–´ë„ ë¬¸ì œ ì—†ë‹¤.
    
    // => ReadLock => WriteLock No (ì½ê¸° -> ì“°ê¸°)
    // ì˜ë¯¸: í˜„ì¬ ìŠ¤ë ˆë“œê°€ ReadLockì„ ê°€ì§€ê³  ìˆëŠ” ìƒíƒœì—ì„œ,
    // ë‹¤ì‹œ WriteLockì„ ìš”ì²­í•˜ë©´ â†’ í—ˆìš©ë˜ì§€ ì•ŠìŒâŒ
    // ì´ìœ :
    // - ReadLockì€ ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ê³µìœ  ì¤‘ì¼ ìˆ˜ ìˆìŒ
    // - ì´ ìƒíƒœì—ì„œ WriteLockì„ í—ˆìš©í•˜ë©´ ë°ì´í„° ì •í•©ì„±ì´ ê¹¨ì§ˆ ìˆ˜ ìˆìŒ
    // - ì¦‰, â€œì½ê¸°ë§Œ ê°€ëŠ¥ ìƒíƒœâ€ì—ì„œ â€œì“°ê¸° ì§„ì…â€ì€ í—ˆìš©í•˜ì§€ ì•ŠìŒ
    
    // SpinLock ì •ì±… (5000ë²ˆ -> Yield) 
    // Yield : ìì‹ ì˜ ì œì–´ê¶Œì„ ì–‘ë³´ 
    class Lock
    {
        // [Unused(0)] [WriteThreadId(15)] [ReadCount(16)]
        // 0000 0000 0000 0000 0000 0000 0000 0000
        // ê°€ì¥ ì™¼ìª½ 0 : Unused(0)
        // ê°€ì¥ ì™¼ìª½ 1 ~ 15 : WriteThreadId(15)
        // ê°€ì¥ ì™¼ìª½ 16 ~ 32 : ReadCount(16)
        // ê¿€íŒ : 16ì§„ìˆ˜ : 2ì§„ìˆ˜ = F : 11111
        const int EMPTY_FLAG = 0x00000000;
        const int WRITE_MASK = 0x7FFF0000;
        const int READ_MASK = 0x0000FFFF;
        const int MAX_SPIN_COUNT = 5000;

        // ReadCount : ReadLockì„ íšë“í–ˆì„ ë•Œ ì—¬ëŸ¬ ì“°ë ˆë“œì—ì„œ Readë¥¼ ì¡ì„ ìˆ˜ ìˆìŒ -> ê·¸ê²ƒì„ ì¹´ìš´íŒ…
        // WriteThreadId : WriteThreadë¥¼ ì¡ê³  ìˆëŠ” í•œê°œì˜ ì“°ë ˆë“œ
        int _flag = EMPTY_FLAG;
        int _writeCount = 0; // ì¬ê·€ì ìœ¼ë¡œ ëª‡ ë²ˆ ì“°ê¸° ë½ì„ ì¡ì•˜ëŠ”ì§€ ì¹´ìš´íŠ¸

        public void WriteLock()
        {

            // ë™ì¼ ì“°ë ˆë“œê°€ WriteLockì„ ì´ë¯¸ íšë“í•˜ê³  ìˆëŠ”ì§€ í™•ì¸
            // í˜„ì¬ ìŠ¤ë ˆë“œê°€ ì´ë¯¸ WriteLockì„ ì¡ê³  ìˆìœ¼ë©´, ê·¸ëƒ¥ ì¹´ìš´íŠ¸ë§Œ ì˜¬ë¦¬ê³  ë¦¬í„´ (ì¬ê·€ í—ˆìš©!!)
            // ìƒìœ„ 15ë¹„íŠ¸ë§Œ ë‚¨ê¸°ê³  ë‚˜ë¨¸ì§€ ì „ë¶€ 0ìœ¼ë¡œ ì§€ìš°ê³  16ë¹„íŠ¸ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì‹œí”„íŠ¸
            // â†’ WriteThreadIdë¥¼ ë§¨ ì•„ë˜ë¡œ ë‚´ë¦¼
            int lockThreadID = (_flag & WRITE_MASK) >> 16; 
            if (Thread.CurrentThread.ManagedThreadId == lockThreadID)
            {
                _writeCount++;
                // â— í•´ë‹¹ ìŠ¤ë ˆë“œë§Œ ì ‘ê·¼í•˜ëŠ” ë³€ìˆ˜ â†’ ê²½ìŸ ì—†ìŒ â†’ ì›ìì„± í•„ìš” âŒ
                return;
            }
            // í—ˆìš©í•˜ì§€ ì•Šìœ¼ë©´?
            // ìœ„ ì½”ë“œ ì—†ì´ ë¬´ì¡°ê±´ _flag == EMPTY_FLAG ìƒíƒœì—ì„œë§Œ ë½ íšë“ í—ˆìš©í•´ì•¼ í•¨. ì¦‰, ìê¸° ìì‹ ì´ë¼ë„ ë‹¤ì‹œ ëª» ë“¤ì–´ê°

            // ì•„ë¬´ë„ WriteLock or ReadLockì„ íšë“í•˜ê³  ìˆì§€ ì•Šì„ ë•Œ, ê²½í•©í•´ì„œ ì†Œìœ ê¶Œì„ ì–»ëŠ”ë‹¤.
            int desired = (Thread.CurrentThread.ManagedThreadId << 16) & WRITE_MASK;
            while(true)
            {
                for (int i = 0; i < MAX_SPIN_COUNT; i++)
                {
                    // ì‹œë„ë¥¼ í•´ì„œ ì„±ê³µí•˜ë©´ return , ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì•„ë¬´ê²ƒë„ ì•ˆ í•˜ê³  ìˆìœ¼ë©´
                    if(Interlocked.CompareExchange(ref _flag, desired, EMPTY_FLAG) == EMPTY_FLAG) // Interlocked: ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ì›ìì (atomic) ì—°ì‚° ì œê³µ â†’ ë°ì´í„° ê²½í•© ë°©ì§€
                    {
                        _writeCount = 1;
                        return;
                    }

                    // if (_flag == EMPTY_FLAG)
                    // {
                    //     _flag = desired;
                    //      return;
                    // }
                }
                Thread.Yield();
                // ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì•„ë¬´ê²ƒë„ ì•ˆ í•˜ê³  ìˆì„ ë•Œ, ë‚´ ìŠ¤ë ˆë“œ IDë¡œ _flagë¥¼ ì„¸íŒ…
                // ì´ ê³¼ì •ì„ "ê²½ìŸí•˜ë©´ì„œ SpinLock"ì´ë¼ê³  í•´


            }
        }
        public void WriteUnlock()
        {
            int lockCount = --_writeCount; // ì¬ê·€ì ìœ¼ë¡œ ì—¬ëŸ¬ ë²ˆ ì¡ì•˜ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ, writeCountë¥¼ 1 ì¤„ì„
            // 0ì´ ë˜ë©´ ì§„ì§œë¡œ ë½ í•´ì œ
            if (lockCount == 0)
            {
                // ì´ˆê¸° ìƒíƒœë¡œ ë³€ê²½
                Interlocked.Exchange(ref _flag, EMPTY_FLAG);
            }

        }
        // ì½ê¸° ë½ ë¶€ë¶„ì€ ì´í•´ê°€ ê°ˆë•Œê¹Œì§€ ë¶„ì„.
        public void ReadLock()
        {

            int lockThreadID = (_flag & WRITE_MASK) >> 16;
            if (Thread.CurrentThread.ManagedThreadId == lockThreadID)
            {
                Interlocked.Increment(ref _flag); // ì¬ê·€ì ìœ¼ë¡œ Write ì¤‘ â†’ Read ê°€ëŠ¥
                // ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ReadLock ê°€ëŠ¥ 
                // â†’ ìŠ¤ë ˆë“œ ê°„ ê²½ìŸ ë°œìƒ ê°€ëŠ¥ â†’ ë°˜ë“œì‹œ ì›ìì  ì¦ê°€ í•„ìš”
                return;
            }
            // ì•„ë¬´ë„ WriteLockì„ íšë“í•˜ê³  ìˆì§€ ì•Šìœ¼ë©´, ReadCountë¥¼ 1 ëŠ˜ë¦°ë‹¤.
            // ReadLock ê°™ì€ ê²½ìš°ëŠ” ëˆ„êµ¬ë‚˜ ì ‘ê·¼ì´ ê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì— ì¿¨í•˜ê²Œ 1ì”© ëŠ˜ë ¤ì¤€ë‹¤.
            while (true)
            {
                for (int i = 0; i < MAX_SPIN_COUNT; i++)
                {
                    // Lock Free Programming ê¸°ì´ˆ

                    // ë§Œì•½ ëˆ„êµ°ê°€ lockì„ ì¡ê³  ìˆë‹¤ë©´(WriteLock) 
                    // expected ê°’ì´ ë‚´ê°€ ì›í•˜ëŠ” ê°’ì´ ì•„ë‹ í…Œë‹ˆê¹  
                    // ì•„ë˜ if ë¬¸ì—ì„œ ì‹¤íŒ¨ë¥¼ í•˜ê²Œ ë  ê²ƒì´ë‹¤.
                    int expected = (_flag & READ_MASK); // READ_MASK ë¶€ë¶„ë§Œ ì¶”ì¶œ

                    
                    // ë‚´ê°€ ì˜ˆìƒí•œ ê°’ì€ expectedê³  ê¸°ëŒ€í•œ ê°’ì€ expected + 1ì¸ë° 
                    // ì•„ë˜ if ë¬¸ì´ ì„±ê³µí–ˆë‹¤ëŠ” ì˜ë¯¸ëŠ” (_flag & WRITE_MASK) == 0ê³¼ ë™ì¼
                    // ì¦‰ flagê³¼ expectedê°€ ë™ì¼ => flagê°’ì„ 1 ë”í•´ì¤Œ
                    // ì¦‰ ReadLockì„ ì„±ê³µí•˜ê³  ë”ì´ìƒ ì‹œë„í•˜ì§€ ì•ŠìŒ
                    if(Interlocked.CompareExchange(ref _flag, expected + 1, expected) == expected)
                    {
                        return;
                    }
                    // ì²´í¬ë¥¼ í•˜ê³  1ì„ ëŠ˜ë¦¬ëŠ” ìƒí™©ì—ì„œ ë‹¤ë¥¸ ì“°ë ˆë“œì—ì„œ ì ‘ê·¼ì„ í•˜ë©´ ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŒ
                    // if ((_flag & WRITE_MASK) == 0)
                    // {
                    //     _flag = _flag + 1;
                    //     return;
                    // }
                }
                Thread.Yield();
            }

            // ìœ„ì˜ ì˜ˆì œë¥¼ ì´í•´í•˜ê¸° ìœ„í•œ ì‹œë‚˜ë¦¬ì˜¤
            // ë‘ê°œì˜ ì“°ë ˆë“œê°€ ê±°ì˜ ë™ì‹œì— ReadLockì— ì§„ì…ì„ í–ˆê³  Aê°€ Bë³´ë‹¤ ë¨¼ì € ì§„ì…ì„ í–ˆë‹¤ë©´
            // A expected : 0
            // B expected : 0
            // flag == 0 ? A => 1
            // flag == 0 ? B => 1 
            // ì´ë ‡ê²Œ ê²½í•©ì„ í•˜ê²Œ ë¨
            // Aê°€ ë¨¼ì € ì‹¤í–‰ë˜ì—ˆë‹¤ê³  ê°€ì •í•˜ë©´
            // flagëŠ” 1ë¡œ ë°”ë€œ => AëŠ” ì„±ê³µ
            // ê·¸ ë‹¤ìŒ BëŠ” flagê°€ ì´ë¯¸ ë°”ë€Œì—ˆê¸° ë•Œë¬¸ì— ì‹¤íŒ¨ => ë‹¤ì‹œ ì¬ì‹œë„

        }
        public void ReadUnlock()
        {
            Interlocked.Decrement(ref _flag);
        }
    }
}
```
## ì¬ê·€ì  ë½(Recursive Lock)ì´ë€?
- í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œê°€ ì´ë¯¸ ë½ì„ ì¡ì€ ìƒíƒœì—ì„œ,
- ê°™ì€ ë½ì„ ë‹¤ì‹œ íšë“í•´ë„ ë¬¸ì œê°€ ì—†ì´ í†µê³¼ë˜ëŠ” ê²ƒ

ì˜ˆì‹œ:
```csharp
lock (_lock)
{
    // ì‘ì—… ì¤‘...
    lock (_lock) // ë˜ ë‹¤ì‹œ ë½ ì‹œë„
    {
        // ë˜ ë‹¤ë¥¸ ì‘ì—…...
    }
}
```
## ì—¬ê¸°ì„œ ì¼ë°˜ ë½(Mutex, SpinLock ë“±)ì´ë©´?
ë¬´í•œ ëŒ€ê¸° ìƒíƒœì— ë¹ ì§ (ë°ë“œë½!)

ì™œëƒë©´ ë‚´ê°€ ë½ì„ ì´ë¯¸ ì¡ê³  ìˆì–´ì„œ ë‹¤ìŒ lockë„ ëª» í’€ê³  ëŒ€ê¸°í•¨
(ìê¸° ìì‹ ì„ ê¸°ë‹¤ë¦¬ëŠ” ìƒí™© = êµì°© ìƒíƒœ)

## ì¬ê·€ì  ë½ì„ "í—ˆìš©"í•˜ë©´?
í˜„ì¬ ìŠ¤ë ˆë“œê°€ ì´ë¯¸ ë½ì„ ê°€ì§€ê³  ìˆëŠ”ì§€ í™•ì¸í•´ì„œ
â†’ ê°™ì€ ìŠ¤ë ˆë“œë¼ë©´ ë‹¤ì‹œ ë½ íšë“ì„ í—ˆìš©í•¨

ëŒ€ì‹  ë½ì„ ëª‡ ë²ˆ ì¡ì•˜ëŠ”ì§€ ì¹´ìš´íŒ…í•´ì•¼ í•¨ (â†’ int _writeCount)
```csharp
if (Thread.CurrentThread.ManagedThreadId == lockThreadID)
{
    _writeCount++; // ê°™ì€ ìŠ¤ë ˆë“œë‹ˆê¹Œ ì¬ê·€ í—ˆìš©!
    return;
}
```
ê·¸ë¦¬ê³  Unlock() ë•Œë„ 1ì”© ì¤„ì´ë©´ì„œ,
ë§ˆì§€ë§‰ì—ë§Œ ì§„ì§œ ë½ì„ í•´ì œí•¨:
```csharp
if (--_writeCount == 0)
    _flag = EMPTY_FLAG;
```

## í˜„ì‹¤ì ì¸ ì¡°ì–¸

ì¼ë°˜ì ìœ¼ë¡œ lockì€ ì¬ê·€ í—ˆìš©ë¨ (Monitor.Enter ê¸°ë°˜)

í•˜ì§€ë§Œ ê³ ì„±ëŠ¥ì´ ì¤‘ìš”í•œ SpinLock ë“±ì€ ë³´í†µ ì¬ê·€ ê¸ˆì§€

ë³µì¡í•œ ì¬ê·€ êµ¬ì¡°ê°€ í•„ìš”í•˜ê±°ë‚˜, ë½ ì¤‘ì— ê°™ì€ í•¨ìˆ˜ ì—¬ëŸ¬ ë²ˆ ë¶€ë¥¼ ìˆ˜ ìˆëŠ” ìƒí™©ì´ë©´ ì¬ê·€ í—ˆìš©ì´ í¸ë¦¬


**Program.csì˜ ì—­í• **
ì‹¤ì œë¡œ Lock í´ë˜ìŠ¤ì˜ WriteLock, WriteUnlockì„ ì‚¬ìš©í•´ì„œ ìŠ¤ë ˆë“œ ë™ì‹œì„± í…ŒìŠ¤íŠ¸í•¨.

count ê°’ì„ ì—¬ëŸ¬ ìŠ¤ë ˆë“œì—ì„œ ì¦ê°€/ê°ì†Œí•˜ëŠ” ì‹¤ìŠµ.
```csharp
using System.Threading.Tasks;
using System.Threading;

namespace ServerCore
{
    class Program
    {
        // lock free programming ê¸°ë²•ê³¼ ë¹„ìŠ·
        static volatile int count = 0; // volatile: _flagì˜ ìºì‹± ìµœì í™” ë°©ì§€ (í•­ìƒ ìµœì‹  ê°’ì„ ë³´ê²Œ í•¨)
        static Lock _lock = new Lock();
        static void Main(string[] args)
        {
            Task t1 = new Task(delegate ()
            {
                for (int i = 0; i < 10000; i++)
                {
                    _lock.WriteLock();
                    _lock.WriteLock();
                    count++;
                    _lock.WriteUnlock();
                    _lock.WriteUnlock();
                    // WriteLock()ì„ 2ë²ˆ ì—°ì† í˜¸ì¶œí•œ ì´ìœ ëŠ” â†’ ì¬ê·€ ë½ì´ ì•ˆë˜ë„ë¡ ì¼ë¶€ëŸ¬ ì‹¤í—˜
                    // â†’ í•œ ë²ˆ ë” ë½ì„ ì¡ìœ¼ë©´ ë‚´ë¶€ì ìœ¼ë¡œ ì¬ê·€ì ìœ¼ë¡œ ë‹¤ì‹œ ë½ ì‹œë„í•˜ëŠ”ì§€ ë³´ê¸° ìœ„í•´

                    // ì—¬ê¸°ì„œ writelockë¼ë¦¬ ì§ì„ ì•ˆë§ì¶°ì£¼ë©´ ë¦¬í„´ì„ ì•ˆí•œë‹¤. 
                }
            }); // ë¸ë ˆê²Œì´íŠ¸ë¥¼ ì‚¬ìš©í•´ì„œ ìµëª…í•¨ìˆ˜ ì„ ì–¸
            Task t2 = new Task(delegate ()
            {
                for (int i = 0; i < 10000; i++)
                {
                    _lock.WriteLock();
                    count--;
                    _lock.WriteUnlock();
                    // ë§Œì•½ì— ì—¬ê¸°ë‘ ìœ„ì—ì„œ writelockì´ ì•„ë‹ˆë¼ readlockì„ í•˜ë©´ ë¦¬ë“œë½ì€ ìƒí˜¸ ë² íƒ€ì ì¸ ë½ì´ ì•„ë‹ˆê¸° ë•Œë¬¸ì— ì´ìƒí•œ ê°’ì´ ë‚˜ì˜¨ë‹¤.
                }
            });
            t1.Start();
            t2.Start();

            Task.WaitAll(t1, t2);
            System.Console.WriteLine(count);
        }
    }
}
```
WritLock, WriteUnlock, ReadLock, ReadUnlockì˜ êµ¬ì¡°
ReadLockì€ ìƒí˜¸ë°°ì œì ì´ì§€ ì•Šê¸° ë•Œë¬¸ì— í•˜ë‚˜í•˜ë‚˜ë§Œ ë“¤ì–´ê°€ëŠ” ê²ƒì´ ì•„ë‹ˆë‹¤
WriteLockì€ ìƒí˜¸ë°°ì œì ìœ¼ë¡œ í•˜ë‚˜ì”©ë§Œ ë“¤ì–´ê°„ë‹¤ (í™”ì¥ì‹¤ ê°œë…)

//-------------------------------------------------------------------------------

âœ… Lock-Freeë€?
ğŸ”„ ë½(lock)ì„ ì“°ì§€ ì•Šê³ ë„ ë™ì‹œì— ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ì•ˆì „í•˜ê²Œ ë°ì´í„°ì— ì ‘ê·¼í•  ìˆ˜ ìˆëŠ” ê¸°ë²•

ì¦‰, ì„œë¡œ ê¸°ë‹¤ë¦¬ì§€ ì•Šê³  ë¸”ë¡œí‚¹(blocking) ì—†ì´ ë°ì´í„°ë¥¼ ì¡°ì‘í•  ìˆ˜ ìˆëŠ” ë°©ì‹
ì˜ˆì‹œë¡œ ë¹„êµí•´ë³´ì
ğŸ”’ ì¼ë°˜ì ì¸ ë½ ì‚¬ìš©
```csharp
lock(_lock)
{
    count++;
}
```
í•œ ìŠ¤ë ˆë“œê°€ ì´ ë¸”ë¡ì„ ë“¤ì–´ê°€ë©´, ë‹¤ë¥¸ ìŠ¤ë ˆë“œëŠ” ëŒ€ê¸°í•¨ (blockë¨)

ğŸ”“ Lock-Free ë°©ì‹
```csharp
Interlocked.Increment(ref count);
```
ë‚´ë¶€ì ìœ¼ë¡œëŠ” í•˜ë“œì›¨ì–´ ìˆ˜ì¤€ì˜ ì›ì ì—°ì‚°(CPU ëª…ë ¹) ì„ ì´ìš©í•´ì„œ,

ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì ‘ê·¼í•´ë„ ì¶©ëŒ ì—†ì´ ì•ˆì „í•˜ê²Œ ë™ì‘í•¨

ë½ì„ ì‚¬ìš©í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ëŒ€ê¸° ì‹œê°„ ì—†ìŒ

ğŸ§  ì™œ Lock-Freeê°€ ì¤‘ìš”í• ê¹Œ?

![Image](https://github.com/user-attachments/assets/c922fc92-c069-459d-bb46-400aea291302)

ğŸ”§ C#ì—ì„œ ìì£¼ ì“°ëŠ” Lock-Free ë„êµ¬ë“¤

![Image](https://github.com/user-attachments/assets/3298c0af-23e4-4e48-b725-23a356dcb4bc)

ğŸ’¡ í•µì‹¬ ë©”ì„œë“œ ì˜ˆì‹œ: Interlocked.CompareExchange
```csharp
int expected = 0;
int newValue = 1;
int result = Interlocked.CompareExchange(ref _flag, newValue, expected);
```
_flagì˜ ê°’ì´ expectedë©´ â†’ newValueë¡œ ë°”ê¾¸ê³ 
ì•„ë‹ˆë©´ ì•„ë¬´ê²ƒë„ ì•ˆ í•¨ (ê·¸ë¦¬ê³  ê¸°ì¡´ ê°’ì„ ë°˜í™˜í•¨)

ì´ê±¸ ê¸°ë°˜ìœ¼ë¡œ ê²½í•© ì—†ì´ ë½ ì—†ì´ ìì› ì œì–´ë¥¼ í•  ìˆ˜ ìˆìŒ.

ğŸ•¹ï¸ ê²Œì„ ì„œë²„ì—ì„œ Lock-Free ì˜ˆì‹œ

ì±„íŒ… ë¡œê·¸ í, ë„¤íŠ¸ì›Œí¬ íŒ¨í‚· í, ì˜¤ë¸Œì íŠ¸ í’€ë§ ë˜ëŠ” ì ‘ì† ìœ ì € ìˆ˜ ì¹´ìš´í„° ê°™ì€ ë‹¨ìˆœ ìˆ«ì ì¡°ì‘ì—ë„ ìì£¼ ì”€
```csharp
Interlocked.Increment(ref connectedUserCount);
```
