멀티 쓰레드 프로그래밍에서 lock의 비중이 60~70프로 정도 차지한다.

언어마다 프레임워크 마다 구현하는 방법은 다르다.

하지만 어떤 철학으로 구현이 되는지 알아보자

![image](https://user-images.githubusercontent.com/75019048/131054460-5955580f-e05f-40c9-8d8c-d06d85462d3f.png)

누군가가 이미 화장실로 들어가 문을 잠구고 있는 상황이라고 가정

이를 해결하기 위한 3가지 선택

**[무작정 기다리는 전략]**

스핀락을 통해 구현 가능

운영체제의 관점에서 보면 직원이 대기를 한다는 것은 직원의 영혼에 빙의를 해서 쓰레드를 실행을 시키는 것을 의미한다. 

단점

이미 들어가 있는 사람이 오랜 시간동안 나오지 않으면 시간을 허비하게 됨

마냥 가벼운 과정은 아니다. ⇒ CPU 점유율이 확 올라감

**[일단 자리로 돌아가서 대기]**

일단 자리로, 나중에 다시 실행하도록 기다리는 방법이다.

context switching을 통해 구현 가능하다.

쓰레드가 자신의 소유권을 포기하는 것으로 (ex. Thread.Sleep, yield)

일단 포기하고 잠시 있다가 나를 실행 시켜달라는 의미이다.

단점은 잠시 있다가 실행이 될때 실행이 될 수도 있고 안될 수도 있게 되어 확률적으로 자신의 실행이 보장된다.

**cf. Context Switching이란?**

Thread는 결국 CPU core가 해당 쓰레드를 실행을 시키는 것을 의미하는데,

무작정 무한정 실행을 시키는 것이 아니라 어느 정도 뒤에 다른 쓰레드를 실행을 할지 

시간을 분배하는데,

분배한 시간이 지나면 이제 다른 쓰레드를 실행하는 것을 context switching이라고 한다.

즉, 자신의 제어권을 다른 쓰레드에게 양도하는 것을 의미한다.

하지만 context switching이 발생하는 상황은 굉장히 많은 부담을 일으키게 된다.

**[이벤트를 통해 통보]**

자신의 실행권을 양도하는 것은 비슷하다.

하지만 랜덤으로 다시 실행이 되는 것이 아니라 일단은 커널(운영체제)에다가 부탁을 하는 방법을 사용한다.

즉, 운영체제에게 특정 이벤트를 셋팅해서 자물쇠가 비면 이벤트를 발생시켜 자신에게 실행 권한을 달라고 요청하는 것을 뜻한다.

운영체제를 통해 실행이 되기 때문에 실행되는 시점이 2번째와는 다르다.

하지만 단점은 운영체제가 부담을 느낄 수 있다.

예를들어 100명이 이와같이 부탁을 하면 운영체제가 굉장한 부담을 느끼기 때문이다.