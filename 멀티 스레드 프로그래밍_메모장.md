멀티스레드 + 네트워크 프로그래밍 이해하기 쉬운 공부 팁

🎯 핵심 개념 먼저 제대로 잡자

1. 멀티스레드	
설명 : 여러 작업을 동시에 수행	
이해 포인트 : 실제로는 "동시에 보이는 빠른 전환"

2. 락(lock)	
설명: 공유 데이터 보호
이해 포인트 : 락 없으면 데이터가 꼬인다 (race condition)

3. 스핀락 
개념: 락을 얻을 때까지 CPU를 쉬지 않고 계속 반복 시도하는 방식

```csharp
while (!TryEnter())
{
    // 락이 풀릴 때까지 계속 루프 (spin)
}
```
- lock 키워드는 안 쓰지만, 결국 임계 구역을 보호하려고 쓰는 구조

- 경합이 짧은 경우엔 빠름 (락 오래 안 잡고 금방 끝날 때)

- 대신 CPU를 계속 쓰기 때문에, 오래 기다리면 비효율적

🧠 핵심:
- 스레드는 계속 "바쁘게 기다림"

- 락이긴 하지만, Thread.Yield()나 Thread.Sleep() 없이 계속 시도해서 얻음

4. 락프리(Lock-Free)

개념: 락을 사용하지 않고, 원자적(atomic) 연산으로 충돌 없이 처리하는 기법

```csharp
int expected = 0;
int newValue = 1;
Interlocked.CompareExchange(ref target, newValue, expected);
```
- 실패해도 다른 스레드에게 양보하지 않음

- 대신 다시 시도함 (retry loop)

- 핵심은 락 없이 데이터 충돌 없이 작업을 수행하는 것

🧠 핵심:
- 락 자체가 없음

- 스레드는 서로 블로킹하지 않음

- 주로 Interlocked, CAS(Compare And Swap) 등을 이용

🔁 스핀락은 락은 맞지만 lock 키워드를 안 쓰는 방식
🔓 락프리는 락이 아예 없는, 진짜 "비동기적 경쟁 회피" 방식

![Image](https://github.com/user-attachments/assets/9e7b4835-6f93-4e30-8a8d-22feeda188ba)

스핀락도 Interlocked나 CAS 같은 원자적 연산을 사용하긴 하지만 "그렇다고 해서 스핀락 = 락프리"는 아니다.

![Image](https://github.com/user-attachments/assets/7255f986-a80b-4a49-9253-1abb0c93c7d3)

🎯 그럼 언제 뭘 써야 돼?
상황	                      추천
공유 자원이 매우 짧게 사용됨	SpinLock (짧은 경합에 효율적)
고성능 멀티스레드 구조 (큐 등)	Lock-Free (병목 없애고 스케일링 좋음)
일반 상황, 직관적 코드	       그냥 lock 쓰는 게 안정적

🔄 기억하기 좋은 비유
SpinLock: 화장실 문 열릴 때까지 계속 붙잡고 기다리는 사람 (줄 서 있음)

Lock-Free: 열려 있으면 들어가고, 안 열리면 옆 화장실 다시 시도하는 사람 (줄 안 섬)

-----------------------------------------------------------------

5. 네트워크	
설명 : 다른 컴퓨터 간 데이터 송수신	
이해 포인트 : TCP/UDP 이해, 송/수신 흐름 파악

6. 패킷 처리	
설명 : 받은 데이터를 해석/응답
이해 포인트 : 직렬화/역직렬화, 핸들러 분리

3. 패턴 이해 > 외우기
lock → 공유 자원 보호

queue → 작업을 순서대로 처리

session → 연결된 클라이언트 관리

패킷 핸들러 → 명령마다 분리

이걸 일정한 패턴으로 이해하고 써보는 게 중요

![Image](https://github.com/user-attachments/assets/abeb6448-d46a-43a0-809f-d0283178d2c7)

💡 추천 학습 루틴
✔️ 동작하는 예제부터 돌려보기

✔️ 로그 찍으면서 흐름 따라가기

✔️ 의심되는 부분 직접 코드로 실험

✔️ 스레드 2~3개부터 시작해서 늘려보기

✔️ 디버거 + 콘솔 로그 병행

--------------------------------------------------------------------------------------------------------------------
## 보통 애플리케이션 / 메모리 레벨에서 C#이나 c++에서 보통 락을 걸게되는 대상
보통 C#/C++ 애플리케이션 레벨에서 “락을 건다”는 것은 **여러 스레드**가 **동시에 접근·수정**하면 안 되는 **공유 자원(shared resource)** 에 대해 상호배제(mutual exclusion)를 걸겠다는 의미.

### 1. 객체 인스턴스(Instance)

* **C#**

  ```csharp
  private readonly object _sync = new object();
  void Foo() {
      lock(_sync) {
          // _sharedField 접근·수정
      }
  }
  ```
* **C++**

  ```cpp
  class MyClass {
      std::mutex mtx;
      int sharedValue;
  public:
      void Foo() {
          std::lock_guard<std::mutex> lk(mtx);
          // sharedValue 접근·수정
      }
  };
  ```

### 2. 컬렉션(리스트·맵 등)

* 리스트, 딕셔너리 같은 **mutable 컬렉션**·컨테이너에 여러 스레드가 동시에 추가·삭제·순회할 때
* `lock(_list)` / `std::mutex` 로 래핑하여 안전하게 사용

### 3. 정적(Static) 자원

* **static 필드·프로퍼티**
* C#의 `lock(typeof(MyClass))` 혹은 `lock(_staticSync)`
* C++의 전역 `std::mutex` 또는 클래스 내 `static std::mutex`

### 4. 공유 변수(Global Variable)

* 여러 스레드가 동시에 읽고 쓰는 전역 변수나 싱글톤 인스턴스
* 반드시 mutex/lock으로 보호

### 5. I/O 자원

* **파일 스트림(FileStream)**, **네트워크 소켓**
* 동시에 닫기(close), 쓰기(write) 작업 시 데이터 난독 방지

### 6. 리소스 풀(Resource Pool)

* DB 커넥션 풀, 스레드 풀, 오브젝트 풀 등
* 풀에서 객체 할당·반환 시 동시성 제어

### 7. 트랜잭션 범위

* \*\*C#\*\*의 `Mutex`/`SemaphoreSlim`/`ReaderWriterLockSlim`
* \*\*C++\*\*의 `std::shared_mutex` (C++17) 등으로

  * 다수 Reader vs 단일 Writer 분리

### 💡 팁

* **전용 락 객체**를 두고(lock on private object) 절대 `lock(this)`나 `lock(typeof(...))`, `lock(string)` 같은 공개 대상에 걸지 마세요.
* 가능한 **락 범위(lock scope)** 는 작게—긴 시간 락 유지 시 교착(deadlock)·성능 저하 위험.
* **Reader/Writer 락**을 활용해 읽기 위주 로직은 동시 실행 허용.

---

### 요약

> C#/C++ 애플리케이션 레벨 락의 대상은
>
> 1. **인스턴스 필드**
> 2. **컬렉션(리스트, 맵 등)**
> 3. **static 변수**
> 4. **공유 전역 변수**
> 5. **I/O 자원(파일·소켓)**
> 6. **리소스 풀**
> 7. **Reader/Writer 구분 가능한 자원**
>
> 이런 공유 자원을 `Mutex`/`lock`/`std::mutex` 등으로 보호해야 스레드 안전(thread-safe)을 보장할 수 있습니다.

--------------------------------------------------------------------------------------------------------------------


멀티 스레드 환경에서 한 스레드가 공유 자원의 값을 바꿨을 때, 다른 스레드에서도 즉시 그 변경된 값을 정확하게 볼 수 있도록 하기 위해서는 
***메모리의 “가시성(visibility)”과 “원자성(atomicity)”을 보장***해야 함.

***1. volatile 키워드***
역할:
volatile을 사용하면, 해당 변수의 값을 CPU 캐시가 아니라 메인 메모리에서 읽고 쓰도록 강제해.
→ 즉, 한 스레드가 값을 변경하면 다른 스레드가 그 최신 값을 바로 볼 수 있게 해준다.

제한:
단순한 읽기/쓰기에는 유용하지만, 복잡한 연산(예를 들어, a = a + 1 같이 읽고 쓰는 연산)은 원자성을 보장하지 못한다.

***2. Interlocked 클래스 (원자적 연산)***
역할:
Interlocked 클래스의 메서드(예: Interlocked.Increment, Interlocked.Decrement, Interlocked.CompareExchange)를 사용하면
해당 연산을 원자적으로 수행하여 데이터 경합 없이 안전하게 값을 업데이트할 수 있어.

장점:

연산이 하드웨어 수준에서 원자적으로 처리되므로 복잡한 락 없이도 높은 성능을 유지할 수 있음.

동시 업데이트 시에도 중간 값이 노출되지 않고, 다른 스레드에 정확한 변경 사항이 반영됨.

***3. 락(Lock) 또는 Monitor***
역할:
lock 구문(C#에서는 Monitor.Enter/Exit을 사용한 문법적 장치)을 사용하면
임계 구역(critical section)을 만들어 한 번에 한 스레드만 해당 코드 블록 내의 공유 자원에 접근할 수 있도록 한다.

락 안에서 작업할 때, 그 영역 내의 코드는 한 번에 한 스레드만 실행되므로 해당 스레드가 공유자원의 값을 변경하면, 
락이 해제된 후 다른 스레드가 락을 획득할 때 그 최신 값을 보게 됩니다.

그리고 외부 함수에서 이미 락을 획득한 상태라면, 그 내부에서 호출하는 함수에서는 동일한 락을 다시 걸지 않아도 되지만, 

해당 함수가 락 획득 여부에 의존하는 경우라면 호출 시점에 반드시 락이 걸려있는지 확인해야 합니다.

Q: 락 안에서 return을 사용하는것은 위험하지 않은가?

일반적으로 C#의 lock 문은 내부적으로 try-finally 블록을 사용하여, 블록을 빠져나갈 때(예외가 발생하거나, return으로 조기 종료되더라도) 

반드시 락 해제(Monitor.Exit)가 실행되도록 보장합니다. 따라서 lock 문 안에서 return을 하더라도, 락이 제대로 해제되므로 구조가 올바르게 작성되어 있다면 위험하지 않습니다.

다만 몇 가지 주의사항은 있습니다:

1. 락을 오래 유지하지 않도록 해야 함: 

락 안에서 return을 하더라도, 락을 불필요하게 오래 유지하면 다른 스레드들이 대기하는 시간이 길어질 수 있으므로, 최소한의 코드 블록으로 묶어야 합니다.

2. 예외 상황 처리: 만약 직접 락을 관리하는 코드를 작성하는 경우(예를 들어, Monitor.Enter/Exit을 직접 사용하는 경우), 
try-finally 블록 없이 return을 하면 락이 해제되지 않아 교착 상태(deadlock)가 발생할 위험이 있으므로 주의해야 합니다.

결론적으로, C#의 lock 문 자체는 return 등으로 인해 블록을 조기 종료하더라도 안전하게 락을 해제하도록 설계되어 있으므로, 
올바르게 사용된다면 락 안에서의 return은 위험하지 않습니다.

특징:

데이터의 일관성을 보장하지만, 락을 과도하게 사용하면 성능 저하 및 스레드 대기 시간이 길어질 수 있음.

복잡한 연산이나 여러 단계의 처리에 대해서는 안전하게 동기화할 수 있음.

***4. 메모리 배리어 (Memory Barriers)***
역할:
때로는 프로그래머가 직접 Thread.MemoryBarrier() 같은 메서드를 호출해,
CPU와 컴파일러에게 명시적으로 메모리 접근 순서를 강제할 수 있다.

용도:
고급 동기화 기법에서, 특히 lock-free 프로그래밍 시에
값의 변경 사항이 다른 스레드에 빠르게 반영되도록 순서를 보장할 때 사용한다.

하지만 MemoryBarrier가 간접적으로 들어가 있는것들이 많다.
Volatile도 그렇고 Lock 같은 경우도 그렇고 아토믹 문법도 다 내부적으로 메모리 베리어가 구현이되어있다.

***5. 동시성 컬렉션 (Concurrent Collections)***
예:
ConcurrentQueue<T>, ConcurrentDictionary<TKey, TValue> 등

이러한 컬렉션들은 내부적으로 락이나 lock-free 알고리즘을 사용해
데이터를 안전하게 읽고 쓸 수 있도록 설계되어 있다.

장점:
사용자 입장에서는 별도의 동기화 코드를 작성하지 않아도 되며,
다수의 스레드가 동시에 접근해도 데이터 일관성이 유지된다.


## 모든 스레드가 메모리의 일관된 최신 상태를 보도록 보장하는 동기화 메커니즘

1. 스핀락(SpinLock):
원자적 연산(예, Interlocked.CompareExchange)과 CPU 메모리 배리어를 이용해,
한 스레드가 락을 잡고 값을 변경하면 락 해제 시 다른 스레드가 그 변경 내용을 확실하게 보게 만드는 기능이 있어.

NET Framework 4.6 이후부터 System.Threading.SpinLock 구조체로 제공되어있다.

2. ReaderWriterLock:
여러 스레드가 읽기 전용 접근은 동시에 가능하지만,
쓰기 전용 접근 시에는 전체 데이터를 배타적으로 보호하므로,
쓰기 락이 해제되면 다른 스레드들이 최신 데이터를 보도록 보장해.

API로 System.Threading.ReaderWriterLock와 더 개선된 System.Threading.ReaderWriterLockSlim이 제공되어 있다.

3. AutoResetEvent:
이벤트 객체를 이용해 한 스레드가 신호를 보내면,
대기 중인 다른 스레드에게 “작업 완료” 혹은 “상태 변경”을 알리면서,
이 때 메모리 배리어 효과가 포함되어 있어서 최신 상태를 확인하게 한다.

API로 System.Threading.AutoResetEvent가 있으며, 
이는 이벤트 신호를 통해 한 스레드가 신호를 받으면 자동으로 리셋되어 대기 중인 다른 스레드가 처리할 수 있도록 한다.

4. 컨텍스트 스위칭:
OS가 스레드를 전환할 때 내부적으로 메모리 배리어를 사용해,
현재 실행 중인 스레드의 메모리 상태를 정리하고 다음 스레드에 전달하므로,
스레드 간 메모리 일관성을 유지하는 데 도움을 준다.

직접적으로 "컨텍스트 스위칭"을 제어하는 API는 없지만, .NET과 운영체제의 스케줄러가 스레드 간 컨텍스트 스위칭을 관리합니다. 
예를 들어, Thread.Sleep(), Thread.Yield() 등의 메서드를 통해 스레드가 잠깐 양보하도록 하여 간접적으로 컨텍스트 스위칭이 일어나도록 할 수 있다.

즉, 이 모든 기법들은 각자의 방식으로 메모리 배리어를 통해
**메모리의 가시성(visibility)**과 **원자성(atomicity)**을 보장하여,
한 스레드에서 값 변경이 일어나면 다른 스레드도 그 변경 내용을 볼 수 있게 만드는 기능이 있다.

그리고, 이러한 기능들은
대부분 API로 제공되거나 운영체제 수준에서 구현된 동기화 프리미티브로 제공된다.
즉, 프로그래머는 보통 직접 이들 동기화 기법을 재구현하지 않고,
. NET, Win32, 또는 C++ STL, Boost와 같은 라이브러리에서 제공하는 API를 사용하게 된다.
