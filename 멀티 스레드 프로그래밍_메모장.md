멀티스레드 + 네트워크 프로그래밍 이해하기 쉬운 공부 팁

🎯 핵심 개념 먼저 제대로 잡자

1. 멀티스레드	
설명 : 여러 작업을 동시에 수행	
이해 포인트 : 실제로는 "동시에 보이는 빠른 전환"

2. 락(lock)	
설명: 공유 데이터 보호
이해 포인트 : 락 없으면 데이터가 꼬인다 (race condition)

3. 스핀락 
개념: 락을 얻을 때까지 CPU를 쉬지 않고 계속 반복 시도하는 방식

```csharp
while (!TryEnter())
{
    // 락이 풀릴 때까지 계속 루프 (spin)
}
```
- lock 키워드는 안 쓰지만, 결국 임계 구역을 보호하려고 쓰는 구조

- 경합이 짧은 경우엔 빠름 (락 오래 안 잡고 금방 끝날 때)

- 대신 CPU를 계속 쓰기 때문에, 오래 기다리면 비효율적

🧠 핵심:
- 스레드는 계속 "바쁘게 기다림"

- 락이긴 하지만, Thread.Yield()나 Thread.Sleep() 없이 계속 시도해서 얻음

4. 락프리(Lock-Free)

개념: 락을 사용하지 않고, 원자적(atomic) 연산으로 충돌 없이 처리하는 기법

```csharp
int expected = 0;
int newValue = 1;
Interlocked.CompareExchange(ref target, newValue, expected);
```
- 실패해도 다른 스레드에게 양보하지 않음

- 대신 다시 시도함 (retry loop)

- 핵심은 락 없이 데이터 충돌 없이 작업을 수행하는 것

🧠 핵심:
- 락 자체가 없음

- 스레드는 서로 블로킹하지 않음

- 주로 Interlocked, CAS(Compare And Swap) 등을 이용

🔁 스핀락은 락은 맞지만 lock 키워드를 안 쓰는 방식
🔓 락프리는 락이 아예 없는, 진짜 "비동기적 경쟁 회피" 방식

![Image](https://github.com/user-attachments/assets/9e7b4835-6f93-4e30-8a8d-22feeda188ba)

스핀락도 Interlocked나 CAS 같은 원자적 연산을 사용하긴 하지만 "그렇다고 해서 스핀락 = 락프리"는 아니다.

![Image](https://github.com/user-attachments/assets/7255f986-a80b-4a49-9253-1abb0c93c7d3)

🎯 그럼 언제 뭘 써야 돼?
상황	                      추천
공유 자원이 매우 짧게 사용됨	SpinLock (짧은 경합에 효율적)
고성능 멀티스레드 구조 (큐 등)	Lock-Free (병목 없애고 스케일링 좋음)
일반 상황, 직관적 코드	       그냥 lock 쓰는 게 안정적

🔄 기억하기 좋은 비유
SpinLock: 화장실 문 열릴 때까지 계속 붙잡고 기다리는 사람 (줄 서 있음)

Lock-Free: 열려 있으면 들어가고, 안 열리면 옆 화장실 다시 시도하는 사람 (줄 안 섬)
-----------------------------------------------------------------

5. 네트워크	
설명 : 다른 컴퓨터 간 데이터 송수신	
이해 포인트 : TCP/UDP 이해, 송/수신 흐름 파악

6. 패킷 처리	
설명 : 받은 데이터를 해석/응답
이해 포인트 : 직렬화/역직렬화, 핸들러 분리

3. 패턴 이해 > 외우기
lock → 공유 자원 보호

queue → 작업을 순서대로 처리

session → 연결된 클라이언트 관리

패킷 핸들러 → 명령마다 분리

이걸 일정한 패턴으로 이해하고 써보는 게 중요

![Image](https://github.com/user-attachments/assets/abeb6448-d46a-43a0-809f-d0283178d2c7)

💡 추천 학습 루틴
✔️ 동작하는 예제부터 돌려보기

✔️ 로그 찍으면서 흐름 따라가기

✔️ 의심되는 부분 직접 코드로 실험

✔️ 스레드 2~3개부터 시작해서 늘려보기

✔️ 디버거 + 콘솔 로그 병행

--------------------------------------------------------------------------------------------------------------------

멀티 스레드 환경에서 한 스레드가 공유 자원의 값을 바꿨을 때, 다른 스레드에서도 즉시 그 변경된 값을 정확하게 볼 수 있도록 하기 위해서는 
***메모리의 “가시성(visibility)”과 “원자성(atomicity)”을 보장***해야 함.

***1. volatile 키워드***
역할:
volatile을 사용하면, 해당 변수의 값을 CPU 캐시가 아니라 메인 메모리에서 읽고 쓰도록 강제해.
→ 즉, 한 스레드가 값을 변경하면 다른 스레드가 그 최신 값을 바로 볼 수 있게 해준다.

제한:
단순한 읽기/쓰기에는 유용하지만, 복잡한 연산(예를 들어, a = a + 1 같이 읽고 쓰는 연산)은 원자성을 보장하지 못한다.

***2. Interlocked 클래스 (원자적 연산)***
역할:
Interlocked 클래스의 메서드(예: Interlocked.Increment, Interlocked.Decrement, Interlocked.CompareExchange)를 사용하면
해당 연산을 원자적으로 수행하여 데이터 경합 없이 안전하게 값을 업데이트할 수 있어.

장점:

연산이 하드웨어 수준에서 원자적으로 처리되므로 복잡한 락 없이도 높은 성능을 유지할 수 있음.

동시 업데이트 시에도 중간 값이 노출되지 않고, 다른 스레드에 정확한 변경 사항이 반영됨.

***3. 락(Lock) 또는 Monitor***
역할:
lock 구문(C#에서는 Monitor.Enter/Exit을 사용한 문법적 장치)을 사용하면
임계 구역(critical section)을 만들어 한 번에 한 스레드만 해당 코드 블록 내의 공유 자원에 접근할 수 있도록 한다.

특징:

데이터의 일관성을 보장하지만, 락을 과도하게 사용하면 성능 저하 및 스레드 대기 시간이 길어질 수 있음.

복잡한 연산이나 여러 단계의 처리에 대해서는 안전하게 동기화할 수 있음.

***4. 메모리 배리어 (Memory Barriers)***
역할:
때로는 프로그래머가 직접 Thread.MemoryBarrier() 같은 메서드를 호출해,
CPU와 컴파일러에게 명시적으로 메모리 접근 순서를 강제할 수 있다.

용도:
고급 동기화 기법에서, 특히 lock-free 프로그래밍 시에
값의 변경 사항이 다른 스레드에 빠르게 반영되도록 순서를 보장할 때 사용한다.

하지만 MemoryBarrier가 간접적으로 들어가 있는것들이 많다.
Volatile도 그렇고 Lock 같은 경우도 그렇고 아토믹 문법도 다 내부적으로 메모리 베리어가 구현이되어있다.

***5. 동시성 컬렉션 (Concurrent Collections)***
예:
ConcurrentQueue<T>, ConcurrentDictionary<TKey, TValue> 등

이러한 컬렉션들은 내부적으로 락이나 lock-free 알고리즘을 사용해
데이터를 안전하게 읽고 쓸 수 있도록 설계되어 있다.

장점:
사용자 입장에서는 별도의 동기화 코드를 작성하지 않아도 되며,
다수의 스레드가 동시에 접근해도 데이터 일관성이 유지된다.


## 모든 스레드가 메모리의 일관된 최신 상태를 보도록 보장하는 동기화 메커니즘

1. 스핀락(SpinLock):
원자적 연산(예, Interlocked.CompareExchange)과 CPU 메모리 배리어를 이용해,
한 스레드가 락을 잡고 값을 변경하면 락 해제 시 다른 스레드가 그 변경 내용을 확실하게 보게 만드는 기능이 있어.

NET Framework 4.6 이후부터 System.Threading.SpinLock 구조체로 제공되어있다.

2. ReaderWriterLock:
여러 스레드가 읽기 전용 접근은 동시에 가능하지만,
쓰기 전용 접근 시에는 전체 데이터를 배타적으로 보호하므로,
쓰기 락이 해제되면 다른 스레드들이 최신 데이터를 보도록 보장해.

API로 System.Threading.ReaderWriterLock와 더 개선된 System.Threading.ReaderWriterLockSlim이 제공되어 있다.

3. AutoResetEvent:
이벤트 객체를 이용해 한 스레드가 신호를 보내면,
대기 중인 다른 스레드에게 “작업 완료” 혹은 “상태 변경”을 알리면서,
이 때 메모리 배리어 효과가 포함되어 있어서 최신 상태를 확인하게 한다.

API로 System.Threading.AutoResetEvent가 있으며, 
이는 이벤트 신호를 통해 한 스레드가 신호를 받으면 자동으로 리셋되어 대기 중인 다른 스레드가 처리할 수 있도록 한다.

4. 컨텍스트 스위칭:
OS가 스레드를 전환할 때 내부적으로 메모리 배리어를 사용해,
현재 실행 중인 스레드의 메모리 상태를 정리하고 다음 스레드에 전달하므로,
스레드 간 메모리 일관성을 유지하는 데 도움을 준다.

직접적으로 "컨텍스트 스위칭"을 제어하는 API는 없지만, .NET과 운영체제의 스케줄러가 스레드 간 컨텍스트 스위칭을 관리합니다. 
예를 들어, Thread.Sleep(), Thread.Yield() 등의 메서드를 통해 스레드가 잠깐 양보하도록 하여 간접적으로 컨텍스트 스위칭이 일어나도록 할 수 있다.

즉, 이 모든 기법들은 각자의 방식으로 메모리 배리어를 통해
**메모리의 가시성(visibility)**과 **원자성(atomicity)**을 보장하여,
한 스레드에서 값 변경이 일어나면 다른 스레드도 그 변경 내용을 볼 수 있게 만드는 기능이 있다.

그리고, 이러한 기능들은
대부분 API로 제공되거나 운영체제 수준에서 구현된 동기화 프리미티브로 제공된다.
즉, 프로그래머는 보통 직접 이들 동기화 기법을 재구현하지 않고,
. NET, Win32, 또는 C++ STL, Boost와 같은 라이브러리에서 제공하는 API를 사용하게 된다.